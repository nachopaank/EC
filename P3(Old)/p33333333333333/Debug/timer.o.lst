   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer.c"
  21              	.Ltext0:
  22              		.file 1 "../timer.c"
 1698              		.align	2
 1699              		.global	tmr_set_prescaler
 1701              	tmr_set_prescaler:
 1702              	.LFB0:
   1:../timer.c    **** /*********************************************************************************************
   2:../timer.c    **** * Fichero:		timer.c
   3:../timer.c    **** * Descrip:		funciones de control del timer0 del s3c44b0x
   4:../timer.c    **** *********************************************************************************************/
   5:../timer.c    **** 
   6:../timer.c    **** /*--- ficheros de cabecera ---*/
   7:../timer.c    **** #include "44b.h"
   8:../timer.c    **** #include "timer.h"
   9:../timer.c    **** 
  10:../timer.c    **** int tmr_set_prescaler(int p, int  value)
  11:../timer.c    **** {
 1703              		.loc 1 11 0
 1704              		.cfi_startproc
 1705              		@ Function supports interworking.
 1706              		@ args = 0, pretend = 0, frame = 16
 1707              		@ frame_needed = 1, uses_anonymous_args = 0
 1708 0000 0DC0A0E1 		mov	ip, sp
 1709              	.LCFI0:
 1710              		.cfi_def_cfa_register 12
 1711 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1712 0008 04B04CE2 		sub	fp, ip, #4
 1713              		.cfi_offset 14, -8
 1714              		.cfi_offset 13, -12
 1715              		.cfi_offset 11, -16
 1716              	.LCFI1:
 1717              		.cfi_def_cfa 11, 4
 1718 000c 10D04DE2 		sub	sp, sp, #16
 1719 0010 18000BE5 		str	r0, [fp, #-24]
 1720 0014 1C100BE5 		str	r1, [fp, #-28]
  12:../timer.c    **** 	int offset = p*8;
 1721              		.loc 1 12 0
 1722 0018 18301BE5 		ldr	r3, [fp, #-24]
 1723 001c 8331A0E1 		mov	r3, r3, asl #3
 1724 0020 10300BE5 		str	r3, [fp, #-16]
  13:../timer.c    **** 	value &= 0xFF;
 1725              		.loc 1 13 0
 1726 0024 1C301BE5 		ldr	r3, [fp, #-28]
 1727 0028 FF3003E2 		and	r3, r3, #255
 1728 002c 1C300BE5 		str	r3, [fp, #-28]
  14:../timer.c    **** 
  15:../timer.c    **** 	if (p < 0 || p > 3)
 1729              		.loc 1 15 0
 1730 0030 18301BE5 		ldr	r3, [fp, #-24]
 1731 0034 000053E3 		cmp	r3, #0
 1732 0038 020000BA 		blt	.L2
 1733              		.loc 1 15 0 is_stmt 0 discriminator 1
 1734 003c 18301BE5 		ldr	r3, [fp, #-24]
 1735 0040 030053E3 		cmp	r3, #3
 1736 0044 010000DA 		ble	.L3
 1737              	.L2:
  16:../timer.c    **** 		return -1;
 1738              		.loc 1 16 0 is_stmt 1
 1739 0048 0030E0E3 		mvn	r3, #0
 1740 004c 110000EA 		b	.L4
 1741              	.L3:
  17:../timer.c    **** 
  18:../timer.c    **** 	//COMPLETAR: escribir el valor value a partir de la posición offset en el
  19:../timer.c    **** 	//registro rTCFG0, para establecer el valor de pre-escalado del módulo p
  20:../timer.c    **** 
  21:../timer.c    **** 	rTCFG0 &= ~(value << offset);
 1742              		.loc 1 21 0
 1743 0050 50309FE5 		ldr	r3, .L5
 1744 0054 4C209FE5 		ldr	r2, .L5
 1745 0058 001092E5 		ldr	r1, [r2, #0]
 1746 005c 1C001BE5 		ldr	r0, [fp, #-28]
 1747 0060 10201BE5 		ldr	r2, [fp, #-16]
 1748 0064 1022A0E1 		mov	r2, r0, asl r2
 1749 0068 0220E0E1 		mvn	r2, r2
 1750 006c 022001E0 		and	r2, r1, r2
 1751 0070 002083E5 		str	r2, [r3, #0]
  22:../timer.c    **** 	rTCFG0 |= (value << offset);
 1752              		.loc 1 22 0
 1753 0074 2C309FE5 		ldr	r3, .L5
 1754 0078 28209FE5 		ldr	r2, .L5
 1755 007c 001092E5 		ldr	r1, [r2, #0]
 1756 0080 1C001BE5 		ldr	r0, [fp, #-28]
 1757 0084 10201BE5 		ldr	r2, [fp, #-16]
 1758 0088 1022A0E1 		mov	r2, r0, asl r2
 1759 008c 022081E1 		orr	r2, r1, r2
 1760 0090 002083E5 		str	r2, [r3, #0]
  23:../timer.c    **** 	return 0;
 1761              		.loc 1 23 0
 1762 0094 0030A0E3 		mov	r3, #0
 1763              	.L4:
  24:../timer.c    **** }
 1764              		.loc 1 24 0
 1765 0098 0300A0E1 		mov	r0, r3
 1766 009c 0CD04BE2 		sub	sp, fp, #12
 1767 00a0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1768 00a4 1EFF2FE1 		bx	lr
 1769              	.L6:
 1770              		.align	2
 1771              	.L5:
 1772 00a8 0000D501 		.word	30736384
 1773              		.cfi_endproc
 1774              	.LFE0:
 1776              		.align	2
 1777              		.global	tmr_set_divider
 1779              	tmr_set_divider:
 1780              	.LFB1:
  25:../timer.c    **** 
  26:../timer.c    **** int tmr_set_divider(int d, enum tmr_div div)
  27:../timer.c    **** {
 1781              		.loc 1 27 0
 1782              		.cfi_startproc
 1783              		@ Function supports interworking.
 1784              		@ args = 0, pretend = 0, frame = 16
 1785              		@ frame_needed = 1, uses_anonymous_args = 0
 1786 00ac 0DC0A0E1 		mov	ip, sp
 1787              	.LCFI2:
 1788              		.cfi_def_cfa_register 12
 1789 00b0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1790 00b4 04B04CE2 		sub	fp, ip, #4
 1791              		.cfi_offset 14, -8
 1792              		.cfi_offset 13, -12
 1793              		.cfi_offset 11, -16
 1794              	.LCFI3:
 1795              		.cfi_def_cfa 11, 4
 1796 00b8 10D04DE2 		sub	sp, sp, #16
 1797 00bc 18000BE5 		str	r0, [fp, #-24]
 1798 00c0 0130A0E1 		mov	r3, r1
 1799 00c4 19304BE5 		strb	r3, [fp, #-25]
  28:../timer.c    **** 	int pos = d*4;
 1800              		.loc 1 28 0
 1801 00c8 18301BE5 		ldr	r3, [fp, #-24]
 1802 00cc 0331A0E1 		mov	r3, r3, asl #2
 1803 00d0 10300BE5 		str	r3, [fp, #-16]
  29:../timer.c    **** 
  30:../timer.c    **** 	if ((d < 0 || d > 5) ||
 1804              		.loc 1 30 0
 1805 00d4 18301BE5 		ldr	r3, [fp, #-24]
 1806 00d8 000053E3 		cmp	r3, #0
 1807 00dc 140000BA 		blt	.L8
 1808              		.loc 1 30 0 is_stmt 0 discriminator 1
 1809 00e0 18301BE5 		ldr	r3, [fp, #-24]
 1810 00e4 050053E3 		cmp	r3, #5
 1811 00e8 110000CA 		bgt	.L8
 1812 00ec 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1813 00f0 040053E3 		cmp	r3, #4
 1814 00f4 0200001A 		bne	.L9
  31:../timer.c    **** 			(div == D1_32 && d > 3) ||
 1815              		.loc 1 31 0 is_stmt 1
 1816 00f8 18301BE5 		ldr	r3, [fp, #-24]
 1817 00fc 030053E3 		cmp	r3, #3
 1818 0100 0B0000CA 		bgt	.L8
 1819              	.L9:
 1820              		.loc 1 31 0 is_stmt 0 discriminator 1
 1821 0104 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1822 0108 050053E3 		cmp	r3, #5
 1823 010c 0200001A 		bne	.L10
  32:../timer.c    **** 			(div == EXTCLK && d != 5) ||
 1824              		.loc 1 32 0 is_stmt 1
 1825 0110 18301BE5 		ldr	r3, [fp, #-24]
 1826 0114 050053E3 		cmp	r3, #5
 1827 0118 0500001A 		bne	.L8
 1828              	.L10:
 1829              		.loc 1 32 0 is_stmt 0 discriminator 1
 1830 011c 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1831 0120 060053E3 		cmp	r3, #6
 1832 0124 0400001A 		bne	.L11
  33:../timer.c    **** 			(div == TCLK && d != 4))
 1833              		.loc 1 33 0 is_stmt 1
 1834 0128 18301BE5 		ldr	r3, [fp, #-24]
 1835 012c 040053E3 		cmp	r3, #4
 1836 0130 0100000A 		beq	.L11
 1837              	.L8:
  34:../timer.c    **** 		return -1;
 1838              		.loc 1 34 0
 1839 0134 0030E0E3 		mvn	r3, #0
 1840 0138 190000EA 		b	.L12
 1841              	.L11:
  35:../timer.c    **** 
  36:../timer.c    **** 	if (div == EXTCLK || div == TCLK)
 1842              		.loc 1 36 0
 1843 013c 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1844 0140 050053E3 		cmp	r3, #5
 1845 0144 0200000A 		beq	.L13
 1846              		.loc 1 36 0 is_stmt 0 discriminator 1
 1847 0148 19305BE5 		ldrb	r3, [fp, #-25]	@ zero_extendqisi2
 1848 014c 060053E3 		cmp	r3, #6
 1849 0150 0100001A 		bne	.L14
 1850              	.L13:
  37:../timer.c    **** 		div = 4;
 1851              		.loc 1 37 0 is_stmt 1
 1852 0154 0430A0E3 		mov	r3, #4
 1853 0158 19304BE5 		strb	r3, [fp, #-25]
 1854              	.L14:
  38:../timer.c    **** 
  39:../timer.c    **** 	//COMPLETAR: escribir el valor div a partir de la posición pos en el
  40:../timer.c    **** 	//registro rTCFG1 para establecer el valor para el divisor d
  41:../timer.c    **** 	rTCFG1 &= ~(0x7 << pos);
 1855              		.loc 1 41 0
 1856 015c 50309FE5 		ldr	r3, .L15
 1857 0160 4C209FE5 		ldr	r2, .L15
 1858 0164 001092E5 		ldr	r1, [r2, #0]
 1859 0168 0700A0E3 		mov	r0, #7
 1860 016c 10201BE5 		ldr	r2, [fp, #-16]
 1861 0170 1022A0E1 		mov	r2, r0, asl r2
 1862 0174 0220E0E1 		mvn	r2, r2
 1863 0178 022001E0 		and	r2, r1, r2
 1864 017c 002083E5 		str	r2, [r3, #0]
  42:../timer.c    **** 	rTCFG1 |= (div << pos);
 1865              		.loc 1 42 0
 1866 0180 2C309FE5 		ldr	r3, .L15
 1867 0184 28209FE5 		ldr	r2, .L15
 1868 0188 001092E5 		ldr	r1, [r2, #0]
 1869 018c 19005BE5 		ldrb	r0, [fp, #-25]	@ zero_extendqisi2
 1870 0190 10201BE5 		ldr	r2, [fp, #-16]
 1871 0194 1022A0E1 		mov	r2, r0, asl r2
 1872 0198 022081E1 		orr	r2, r1, r2
 1873 019c 002083E5 		str	r2, [r3, #0]
  43:../timer.c    **** 
  44:../timer.c    **** 	return 0;
 1874              		.loc 1 44 0
 1875 01a0 0030A0E3 		mov	r3, #0
 1876              	.L12:
  45:../timer.c    **** }
 1877              		.loc 1 45 0
 1878 01a4 0300A0E1 		mov	r0, r3
 1879 01a8 0CD04BE2 		sub	sp, fp, #12
 1880 01ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1881 01b0 1EFF2FE1 		bx	lr
 1882              	.L16:
 1883              		.align	2
 1884              	.L15:
 1885 01b4 0400D501 		.word	30736388
 1886              		.cfi_endproc
 1887              	.LFE1:
 1889              		.align	2
 1890              		.global	tmr_set_count
 1892              	tmr_set_count:
 1893              	.LFB2:
  46:../timer.c    **** 
  47:../timer.c    **** int tmr_set_count(enum tmr_timer t, int count, int cmp)
  48:../timer.c    **** {
 1894              		.loc 1 48 0
 1895              		.cfi_startproc
 1896              		@ Function supports interworking.
 1897              		@ args = 0, pretend = 0, frame = 24
 1898              		@ frame_needed = 1, uses_anonymous_args = 0
 1899 01b8 0DC0A0E1 		mov	ip, sp
 1900              	.LCFI4:
 1901              		.cfi_def_cfa_register 12
 1902 01bc 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1903 01c0 04B04CE2 		sub	fp, ip, #4
 1904              		.cfi_offset 14, -8
 1905              		.cfi_offset 13, -12
 1906              		.cfi_offset 11, -16
 1907              	.LCFI5:
 1908              		.cfi_def_cfa 11, 4
 1909 01c4 18D04DE2 		sub	sp, sp, #24
 1910 01c8 0030A0E1 		mov	r3, r0
 1911 01cc 1C100BE5 		str	r1, [fp, #-28]
 1912 01d0 20200BE5 		str	r2, [fp, #-32]
 1913 01d4 15304BE5 		strb	r3, [fp, #-21]
  49:../timer.c    **** 	int err = 0;
 1914              		.loc 1 49 0
 1915 01d8 0030A0E3 		mov	r3, #0
 1916 01dc 10300BE5 		str	r3, [fp, #-16]
  50:../timer.c    **** 	switch (t) {
 1917              		.loc 1 50 0
 1918 01e0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 1919 01e4 050053E3 		cmp	r3, #5
 1920 01e8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1921 01ec 2C0000EA 		b	.L18
 1922              	.L25:
 1923 01f0 08020000 		.word	.L19
 1924 01f4 24020000 		.word	.L20
 1925 01f8 40020000 		.word	.L21
 1926 01fc 5C020000 		.word	.L22
 1927 0200 78020000 		.word	.L23
 1928 0204 94020000 		.word	.L24
 1929              	.L19:
  51:../timer.c    **** 		case TIMER0:
  52:../timer.c    **** 			//COMPLETAR: establecer el valor de cuenta count y el valor de
  53:../timer.c    **** 			//comparación cmp en los registros de buffer del timer0 (rTCNTB0 y
  54:../timer.c    **** 			//rTCMPB0)
  55:../timer.c    **** 			rTCNTB0 = count;
 1930              		.loc 1 55 0
 1931 0208 B0309FE5 		ldr	r3, .L27
 1932 020c 1C201BE5 		ldr	r2, [fp, #-28]
 1933 0210 002083E5 		str	r2, [r3, #0]
  56:../timer.c    **** 			rTCMPB0 = cmp;
 1934              		.loc 1 56 0
 1935 0214 A8309FE5 		ldr	r3, .L27+4
 1936 0218 20201BE5 		ldr	r2, [fp, #-32]
 1937 021c 002083E5 		str	r2, [r3, #0]
  57:../timer.c    **** 			 break;
 1938              		.loc 1 57 0
 1939 0220 210000EA 		b	.L26
 1940              	.L20:
  58:../timer.c    **** 		case TIMER1:
  59:../timer.c    **** 			//COMPLETAR: establecer el valor de cuenta count y el valor de
  60:../timer.c    **** 			//comparación cmp en los registros de buffer del timer1 (rTCNTB1 y
  61:../timer.c    **** 			//rTCMPB1)
  62:../timer.c    **** 			rTCNTB1 = count;
 1941              		.loc 1 62 0
 1942 0224 9C309FE5 		ldr	r3, .L27+8
 1943 0228 1C201BE5 		ldr	r2, [fp, #-28]
 1944 022c 002083E5 		str	r2, [r3, #0]
  63:../timer.c    **** 			rTCMPB1 = cmp;
 1945              		.loc 1 63 0
 1946 0230 94309FE5 		ldr	r3, .L27+12
 1947 0234 20201BE5 		ldr	r2, [fp, #-32]
 1948 0238 002083E5 		str	r2, [r3, #0]
  64:../timer.c    **** 			 break;
 1949              		.loc 1 64 0
 1950 023c 1A0000EA 		b	.L26
 1951              	.L21:
  65:../timer.c    **** 		case TIMER2:
  66:../timer.c    **** 			//COMPLETAR: establecer el valor de cuenta count y el valor de
  67:../timer.c    **** 			//comparación cmp en los registros de buffer del timer2 (rTCNTB2 y
  68:../timer.c    **** 			//rTCMPB2)
  69:../timer.c    **** 			rTCNTB2 = count;
 1952              		.loc 1 69 0
 1953 0240 88309FE5 		ldr	r3, .L27+16
 1954 0244 1C201BE5 		ldr	r2, [fp, #-28]
 1955 0248 002083E5 		str	r2, [r3, #0]
  70:../timer.c    **** 			rTCMPB2 = cmp;
 1956              		.loc 1 70 0
 1957 024c 80309FE5 		ldr	r3, .L27+20
 1958 0250 20201BE5 		ldr	r2, [fp, #-32]
 1959 0254 002083E5 		str	r2, [r3, #0]
  71:../timer.c    **** 			 break;
 1960              		.loc 1 71 0
 1961 0258 130000EA 		b	.L26
 1962              	.L22:
  72:../timer.c    **** 		case TIMER3:
  73:../timer.c    **** 			//COMPLETAR: establecer el valor de cuenta count y el valor de
  74:../timer.c    **** 			//comparación cmp en los registros de buffer del timer3 (rTCNTB3 y
  75:../timer.c    **** 			//rTCMPB3)
  76:../timer.c    **** 			rTCNTB3 = count;
 1963              		.loc 1 76 0
 1964 025c 74309FE5 		ldr	r3, .L27+24
 1965 0260 1C201BE5 		ldr	r2, [fp, #-28]
 1966 0264 002083E5 		str	r2, [r3, #0]
  77:../timer.c    **** 			rTCMPB3 = cmp;
 1967              		.loc 1 77 0
 1968 0268 6C309FE5 		ldr	r3, .L27+28
 1969 026c 20201BE5 		ldr	r2, [fp, #-32]
 1970 0270 002083E5 		str	r2, [r3, #0]
  78:../timer.c    **** 			 break;
 1971              		.loc 1 78 0
 1972 0274 0C0000EA 		b	.L26
 1973              	.L23:
  79:../timer.c    **** 		case TIMER4:
  80:../timer.c    **** 			//COMPLETAR: establecer el valor de cuenta count y el valor de
  81:../timer.c    **** 			//comparación cmp en los registros de buffer del timer4 (rTCNTB4 y
  82:../timer.c    **** 			//rTCMPB4)
  83:../timer.c    **** 			rTCNTB4 = count;
 1974              		.loc 1 83 0
 1975 0278 60309FE5 		ldr	r3, .L27+32
 1976 027c 1C201BE5 		ldr	r2, [fp, #-28]
 1977 0280 002083E5 		str	r2, [r3, #0]
  84:../timer.c    **** 			rTCMPB4 = cmp;
 1978              		.loc 1 84 0
 1979 0284 58309FE5 		ldr	r3, .L27+36
 1980 0288 20201BE5 		ldr	r2, [fp, #-32]
 1981 028c 002083E5 		str	r2, [r3, #0]
  85:../timer.c    **** 			 break;
 1982              		.loc 1 85 0
 1983 0290 050000EA 		b	.L26
 1984              	.L24:
  86:../timer.c    **** 		case TIMER5:
  87:../timer.c    **** 			//COMPLETAR: establecer el valor de cuenta count en el registro de
  88:../timer.c    **** 			//buffer del timer5 (rTCNTB5)
  89:../timer.c    **** 			rTCNTB5 = count;
 1985              		.loc 1 89 0
 1986 0294 4C309FE5 		ldr	r3, .L27+40
 1987 0298 1C201BE5 		ldr	r2, [fp, #-28]
 1988 029c 002083E5 		str	r2, [r3, #0]
  90:../timer.c    **** 			 break;
 1989              		.loc 1 90 0
 1990 02a0 010000EA 		b	.L26
 1991              	.L18:
  91:../timer.c    **** 		default:
  92:../timer.c    **** 			err = -1;
 1992              		.loc 1 92 0
 1993 02a4 0030E0E3 		mvn	r3, #0
 1994 02a8 10300BE5 		str	r3, [fp, #-16]
 1995              	.L26:
  93:../timer.c    **** 	}
  94:../timer.c    **** 
  95:../timer.c    **** 	return err;
 1996              		.loc 1 95 0
 1997 02ac 10301BE5 		ldr	r3, [fp, #-16]
  96:../timer.c    **** }
 1998              		.loc 1 96 0
 1999 02b0 0300A0E1 		mov	r0, r3
 2000 02b4 0CD04BE2 		sub	sp, fp, #12
 2001 02b8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2002 02bc 1EFF2FE1 		bx	lr
 2003              	.L28:
 2004              		.align	2
 2005              	.L27:
 2006 02c0 0C00D501 		.word	30736396
 2007 02c4 1000D501 		.word	30736400
 2008 02c8 1800D501 		.word	30736408
 2009 02cc 1C00D501 		.word	30736412
 2010 02d0 2400D501 		.word	30736420
 2011 02d4 2800D501 		.word	30736424
 2012 02d8 3000D501 		.word	30736432
 2013 02dc 3400D501 		.word	30736436
 2014 02e0 3C00D501 		.word	30736444
 2015 02e4 4000D501 		.word	30736448
 2016 02e8 4800D501 		.word	30736456
 2017              		.cfi_endproc
 2018              	.LFE2:
 2020              		.align	2
 2021              		.global	tmr_update
 2023              	tmr_update:
 2024              	.LFB3:
  97:../timer.c    **** 
  98:../timer.c    **** int tmr_update(enum tmr_timer t)
  99:../timer.c    **** {
 2025              		.loc 1 99 0
 2026              		.cfi_startproc
 2027              		@ Function supports interworking.
 2028              		@ args = 0, pretend = 0, frame = 16
 2029              		@ frame_needed = 1, uses_anonymous_args = 0
 2030 02ec 0DC0A0E1 		mov	ip, sp
 2031              	.LCFI6:
 2032              		.cfi_def_cfa_register 12
 2033 02f0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2034 02f4 04B04CE2 		sub	fp, ip, #4
 2035              		.cfi_offset 14, -8
 2036              		.cfi_offset 13, -12
 2037              		.cfi_offset 11, -16
 2038              	.LCFI7:
 2039              		.cfi_def_cfa 11, 4
 2040 02f8 10D04DE2 		sub	sp, sp, #16
 2041 02fc 0030A0E1 		mov	r3, r0
 2042 0300 15304BE5 		strb	r3, [fp, #-21]
 100:../timer.c    **** 	int pos = t*4;
 2043              		.loc 1 100 0
 2044 0304 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2045 0308 0331A0E1 		mov	r3, r3, asl #2
 2046 030c 10300BE5 		str	r3, [fp, #-16]
 101:../timer.c    **** 	if (t > 0)
 2047              		.loc 1 101 0
 2048 0310 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2049 0314 000053E3 		cmp	r3, #0
 2050 0318 0200000A 		beq	.L30
 102:../timer.c    **** 		pos += 4;
 2051              		.loc 1 102 0
 2052 031c 10301BE5 		ldr	r3, [fp, #-16]
 2053 0320 043083E2 		add	r3, r3, #4
 2054 0324 10300BE5 		str	r3, [fp, #-16]
 2055              	.L30:
 103:../timer.c    **** 
 104:../timer.c    **** 	if (t < 0 || t > 5)
 2056              		.loc 1 104 0
 2057 0328 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2058 032c 050053E3 		cmp	r3, #5
 2059 0330 0100009A 		bls	.L31
 105:../timer.c    **** 		return -1;
 2060              		.loc 1 105 0
 2061 0334 0030E0E3 		mvn	r3, #0
 2062 0338 110000EA 		b	.L32
 2063              	.L31:
 106:../timer.c    **** 
 107:../timer.c    **** 
 108:../timer.c    **** 	//COMPLETAR: poner a 1 en el registro rTCON el bit indicado por pos
 109:../timer.c    **** 	// y justo después ponerlo a 0 (deben ser stores distintos, lo hacemos con
 110:../timer.c    **** 	// sentencias C distintas)
 111:../timer.c    **** 	rTCON |= (0x2 << pos);
 2064              		.loc 1 111 0
 2065 033c 50309FE5 		ldr	r3, .L33
 2066 0340 4C209FE5 		ldr	r2, .L33
 2067 0344 001092E5 		ldr	r1, [r2, #0]
 2068 0348 0200A0E3 		mov	r0, #2
 2069 034c 10201BE5 		ldr	r2, [fp, #-16]
 2070 0350 1022A0E1 		mov	r2, r0, asl r2
 2071 0354 022081E1 		orr	r2, r1, r2
 2072 0358 002083E5 		str	r2, [r3, #0]
 112:../timer.c    **** 	rTCON &= ~(0x2 << pos);
 2073              		.loc 1 112 0
 2074 035c 30309FE5 		ldr	r3, .L33
 2075 0360 2C209FE5 		ldr	r2, .L33
 2076 0364 001092E5 		ldr	r1, [r2, #0]
 2077 0368 0200A0E3 		mov	r0, #2
 2078 036c 10201BE5 		ldr	r2, [fp, #-16]
 2079 0370 1022A0E1 		mov	r2, r0, asl r2
 2080 0374 0220E0E1 		mvn	r2, r2
 2081 0378 022001E0 		and	r2, r1, r2
 2082 037c 002083E5 		str	r2, [r3, #0]
 113:../timer.c    **** 
 114:../timer.c    **** 	return 0;
 2083              		.loc 1 114 0
 2084 0380 0030A0E3 		mov	r3, #0
 2085              	.L32:
 115:../timer.c    **** }
 2086              		.loc 1 115 0
 2087 0384 0300A0E1 		mov	r0, r3
 2088 0388 0CD04BE2 		sub	sp, fp, #12
 2089 038c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2090 0390 1EFF2FE1 		bx	lr
 2091              	.L34:
 2092              		.align	2
 2093              	.L33:
 2094 0394 0800D501 		.word	30736392
 2095              		.cfi_endproc
 2096              	.LFE3:
 2098              		.align	2
 2099              		.global	tmr_set_mode
 2101              	tmr_set_mode:
 2102              	.LFB4:
 116:../timer.c    **** 
 117:../timer.c    **** int tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)
 118:../timer.c    **** {
 2103              		.loc 1 118 0
 2104              		.cfi_startproc
 2105              		@ Function supports interworking.
 2106              		@ args = 0, pretend = 0, frame = 16
 2107              		@ frame_needed = 1, uses_anonymous_args = 0
 2108 0398 0DC0A0E1 		mov	ip, sp
 2109              	.LCFI8:
 2110              		.cfi_def_cfa_register 12
 2111 039c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2112 03a0 04B04CE2 		sub	fp, ip, #4
 2113              		.cfi_offset 14, -8
 2114              		.cfi_offset 13, -12
 2115              		.cfi_offset 11, -16
 2116              	.LCFI9:
 2117              		.cfi_def_cfa 11, 4
 2118 03a4 10D04DE2 		sub	sp, sp, #16
 2119 03a8 0020A0E1 		mov	r2, r0
 2120 03ac 0130A0E1 		mov	r3, r1
 2121 03b0 15204BE5 		strb	r2, [fp, #-21]
 2122 03b4 16304BE5 		strb	r3, [fp, #-22]
 119:../timer.c    **** 	int err = 0;
 2123              		.loc 1 119 0
 2124 03b8 0030A0E3 		mov	r3, #0
 2125 03bc 10300BE5 		str	r3, [fp, #-16]
 120:../timer.c    **** 	int pos = t*4;
 2126              		.loc 1 120 0
 2127 03c0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2128 03c4 0331A0E1 		mov	r3, r3, asl #2
 2129 03c8 14300BE5 		str	r3, [fp, #-20]
 121:../timer.c    **** 	if (t > 0)
 2130              		.loc 1 121 0
 2131 03cc 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2132 03d0 000053E3 		cmp	r3, #0
 2133 03d4 0200000A 		beq	.L36
 122:../timer.c    **** 		pos += 4;
 2134              		.loc 1 122 0
 2135 03d8 14301BE5 		ldr	r3, [fp, #-20]
 2136 03dc 043083E2 		add	r3, r3, #4
 2137 03e0 14300BE5 		str	r3, [fp, #-20]
 2138              	.L36:
 123:../timer.c    **** 
 124:../timer.c    **** 	if (t < 0 || t > 5)
 2139              		.loc 1 124 0
 2140 03e4 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2141 03e8 050053E3 		cmp	r3, #5
 2142 03ec 0100009A 		bls	.L37
 125:../timer.c    **** 		return -1;
 2143              		.loc 1 125 0
 2144 03f0 0030E0E3 		mvn	r3, #0
 2145 03f4 1B0000EA 		b	.L38
 2146              	.L37:
 126:../timer.c    **** 
 127:../timer.c    **** 	if (mode == ONE_SHOT)
 2147              		.loc 1 127 0
 2148 03f8 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 2149 03fc 000053E3 		cmp	r3, #0
 2150 0400 0900001A 		bne	.L39
 128:../timer.c    **** 		rTCON &= ~(0x8 << pos);
 2151              		.loc 1 128 0
 2152 0404 6C309FE5 		ldr	r3, .L42
 2153 0408 68209FE5 		ldr	r2, .L42
 2154 040c 001092E5 		ldr	r1, [r2, #0]
 2155 0410 0800A0E3 		mov	r0, #8
 2156 0414 14201BE5 		ldr	r2, [fp, #-20]
 2157 0418 1022A0E1 		mov	r2, r0, asl r2
 2158 041c 0220E0E1 		mvn	r2, r2
 2159 0420 022001E0 		and	r2, r1, r2
 2160 0424 002083E5 		str	r2, [r3, #0]
 2161 0428 0D0000EA 		b	.L40
 2162              	.L39:
 129:../timer.c    **** 		//COMPLETAR: poner a 0 el bit autoreload a partir de la posición pos (es
 130:../timer.c    **** 		//el cuarto bit a partir de esa posición)
 131:../timer.c    **** 	else if (mode == RELOAD)
 2163              		.loc 1 131 0
 2164 042c 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 2165 0430 010053E3 		cmp	r3, #1
 2166 0434 0800001A 		bne	.L41
 132:../timer.c    **** 		rTCON |= (0x8 << pos);
 2167              		.loc 1 132 0
 2168 0438 38309FE5 		ldr	r3, .L42
 2169 043c 34209FE5 		ldr	r2, .L42
 2170 0440 001092E5 		ldr	r1, [r2, #0]
 2171 0444 0800A0E3 		mov	r0, #8
 2172 0448 14201BE5 		ldr	r2, [fp, #-20]
 2173 044c 1022A0E1 		mov	r2, r0, asl r2
 2174 0450 022081E1 		orr	r2, r1, r2
 2175 0454 002083E5 		str	r2, [r3, #0]
 2176 0458 010000EA 		b	.L40
 2177              	.L41:
 133:../timer.c    **** 		//COMPLETAR: poner a 1 el bit autoreload a partir de la posición pos (es
 134:../timer.c    **** 		//el cuarto bit a partir de esa posición)
 135:../timer.c    **** 	else
 136:../timer.c    **** 		err = -1;
 2178              		.loc 1 136 0
 2179 045c 0030E0E3 		mvn	r3, #0
 2180 0460 10300BE5 		str	r3, [fp, #-16]
 2181              	.L40:
 137:../timer.c    **** 
 138:../timer.c    **** 	return err;
 2182              		.loc 1 138 0
 2183 0464 10301BE5 		ldr	r3, [fp, #-16]
 2184              	.L38:
 139:../timer.c    **** }
 2185              		.loc 1 139 0
 2186 0468 0300A0E1 		mov	r0, r3
 2187 046c 0CD04BE2 		sub	sp, fp, #12
 2188 0470 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2189 0474 1EFF2FE1 		bx	lr
 2190              	.L43:
 2191              		.align	2
 2192              	.L42:
 2193 0478 0800D501 		.word	30736392
 2194              		.cfi_endproc
 2195              	.LFE4:
 2197              		.align	2
 2198              		.global	tmr_start
 2200              	tmr_start:
 2201              	.LFB5:
 140:../timer.c    **** 
 141:../timer.c    **** int tmr_start(enum tmr_timer t)
 142:../timer.c    **** {
 2202              		.loc 1 142 0
 2203              		.cfi_startproc
 2204              		@ Function supports interworking.
 2205              		@ args = 0, pretend = 0, frame = 16
 2206              		@ frame_needed = 1, uses_anonymous_args = 0
 2207 047c 0DC0A0E1 		mov	ip, sp
 2208              	.LCFI10:
 2209              		.cfi_def_cfa_register 12
 2210 0480 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2211 0484 04B04CE2 		sub	fp, ip, #4
 2212              		.cfi_offset 14, -8
 2213              		.cfi_offset 13, -12
 2214              		.cfi_offset 11, -16
 2215              	.LCFI11:
 2216              		.cfi_def_cfa 11, 4
 2217 0488 10D04DE2 		sub	sp, sp, #16
 2218 048c 0030A0E1 		mov	r3, r0
 2219 0490 15304BE5 		strb	r3, [fp, #-21]
 143:../timer.c    **** 	int pos = t*4;
 2220              		.loc 1 143 0
 2221 0494 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2222 0498 0331A0E1 		mov	r3, r3, asl #2
 2223 049c 10300BE5 		str	r3, [fp, #-16]
 144:../timer.c    **** 	if (t > 0)
 2224              		.loc 1 144 0
 2225 04a0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2226 04a4 000053E3 		cmp	r3, #0
 2227 04a8 0200000A 		beq	.L45
 145:../timer.c    **** 		pos += 4;
 2228              		.loc 1 145 0
 2229 04ac 10301BE5 		ldr	r3, [fp, #-16]
 2230 04b0 043083E2 		add	r3, r3, #4
 2231 04b4 10300BE5 		str	r3, [fp, #-16]
 2232              	.L45:
 146:../timer.c    **** 
 147:../timer.c    **** 	if (t < 0 || t > 5)
 2233              		.loc 1 147 0
 2234 04b8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2235 04bc 050053E3 		cmp	r3, #5
 2236 04c0 0100009A 		bls	.L46
 148:../timer.c    **** 		return -1;
 2237              		.loc 1 148 0
 2238 04c4 0030E0E3 		mvn	r3, #0
 2239 04c8 080000EA 		b	.L47
 2240              	.L46:
 149:../timer.c    **** 
 150:../timer.c    **** 	//COMPLETAR: poner a 1 el bit de start a partir de la posición pos en el
 151:../timer.c    **** 	//registro rTCON (es el primer bit del grupo)
 152:../timer.c    **** 	rTCON |= (0x1 << pos);
 2241              		.loc 1 152 0
 2242 04cc 2C309FE5 		ldr	r3, .L48
 2243 04d0 28209FE5 		ldr	r2, .L48
 2244 04d4 001092E5 		ldr	r1, [r2, #0]
 2245 04d8 0100A0E3 		mov	r0, #1
 2246 04dc 10201BE5 		ldr	r2, [fp, #-16]
 2247 04e0 1022A0E1 		mov	r2, r0, asl r2
 2248 04e4 022081E1 		orr	r2, r1, r2
 2249 04e8 002083E5 		str	r2, [r3, #0]
 153:../timer.c    **** 	return 0;
 2250              		.loc 1 153 0
 2251 04ec 0030A0E3 		mov	r3, #0
 2252              	.L47:
 154:../timer.c    **** }
 2253              		.loc 1 154 0
 2254 04f0 0300A0E1 		mov	r0, r3
 2255 04f4 0CD04BE2 		sub	sp, fp, #12
 2256 04f8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2257 04fc 1EFF2FE1 		bx	lr
 2258              	.L49:
 2259              		.align	2
 2260              	.L48:
 2261 0500 0800D501 		.word	30736392
 2262              		.cfi_endproc
 2263              	.LFE5:
 2265              		.align	2
 2266              		.global	tmr_stop
 2268              	tmr_stop:
 2269              	.LFB6:
 155:../timer.c    **** 
 156:../timer.c    **** int tmr_stop(enum tmr_timer t)
 157:../timer.c    **** {
 2270              		.loc 1 157 0
 2271              		.cfi_startproc
 2272              		@ Function supports interworking.
 2273              		@ args = 0, pretend = 0, frame = 16
 2274              		@ frame_needed = 1, uses_anonymous_args = 0
 2275 0504 0DC0A0E1 		mov	ip, sp
 2276              	.LCFI12:
 2277              		.cfi_def_cfa_register 12
 2278 0508 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2279 050c 04B04CE2 		sub	fp, ip, #4
 2280              		.cfi_offset 14, -8
 2281              		.cfi_offset 13, -12
 2282              		.cfi_offset 11, -16
 2283              	.LCFI13:
 2284              		.cfi_def_cfa 11, 4
 2285 0510 10D04DE2 		sub	sp, sp, #16
 2286 0514 0030A0E1 		mov	r3, r0
 2287 0518 15304BE5 		strb	r3, [fp, #-21]
 158:../timer.c    **** 	int pos = t*4;
 2288              		.loc 1 158 0
 2289 051c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2290 0520 0331A0E1 		mov	r3, r3, asl #2
 2291 0524 10300BE5 		str	r3, [fp, #-16]
 159:../timer.c    **** 	if (t > 0)
 2292              		.loc 1 159 0
 2293 0528 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2294 052c 000053E3 		cmp	r3, #0
 2295 0530 0200000A 		beq	.L51
 160:../timer.c    **** 		pos += 4;
 2296              		.loc 1 160 0
 2297 0534 10301BE5 		ldr	r3, [fp, #-16]
 2298 0538 043083E2 		add	r3, r3, #4
 2299 053c 10300BE5 		str	r3, [fp, #-16]
 2300              	.L51:
 161:../timer.c    **** 
 162:../timer.c    **** 	if (t < 0 || t > 5)
 2301              		.loc 1 162 0
 2302 0540 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2303 0544 050053E3 		cmp	r3, #5
 2304 0548 0100009A 		bls	.L52
 163:../timer.c    **** 		return -1;
 2305              		.loc 1 163 0
 2306 054c 0030E0E3 		mvn	r3, #0
 2307 0550 090000EA 		b	.L53
 2308              	.L52:
 164:../timer.c    **** 
 165:../timer.c    **** 	//COMPLETAR: poner a 0 el bit de start a partir de la posición pos en el
 166:../timer.c    **** 	//registro rTCON (es el primer bit del grupo)
 167:../timer.c    **** 	rTCON &= ~(0x1 << pos);
 2309              		.loc 1 167 0
 2310 0554 30309FE5 		ldr	r3, .L54
 2311 0558 2C209FE5 		ldr	r2, .L54
 2312 055c 001092E5 		ldr	r1, [r2, #0]
 2313 0560 0100A0E3 		mov	r0, #1
 2314 0564 10201BE5 		ldr	r2, [fp, #-16]
 2315 0568 1022A0E1 		mov	r2, r0, asl r2
 2316 056c 0220E0E1 		mvn	r2, r2
 2317 0570 022001E0 		and	r2, r1, r2
 2318 0574 002083E5 		str	r2, [r3, #0]
 168:../timer.c    **** 	return 0;
 2319              		.loc 1 168 0
 2320 0578 0030A0E3 		mov	r3, #0
 2321              	.L53:
 169:../timer.c    **** }
 2322              		.loc 1 169 0
 2323 057c 0300A0E1 		mov	r0, r3
 2324 0580 0CD04BE2 		sub	sp, fp, #12
 2325 0584 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2326 0588 1EFF2FE1 		bx	lr
 2327              	.L55:
 2328              		.align	2
 2329              	.L54:
 2330 058c 0800D501 		.word	30736392
 2331              		.cfi_endproc
 2332              	.LFE6:
 2334              		.align	2
 2335              		.global	tmr_isrunning
 2337              	tmr_isrunning:
 2338              	.LFB7:
 170:../timer.c    **** 
 171:../timer.c    **** int tmr_isrunning(enum tmr_timer t)
 172:../timer.c    **** {
 2339              		.loc 1 172 0
 2340              		.cfi_startproc
 2341              		@ Function supports interworking.
 2342              		@ args = 0, pretend = 0, frame = 16
 2343              		@ frame_needed = 1, uses_anonymous_args = 0
 2344 0590 0DC0A0E1 		mov	ip, sp
 2345              	.LCFI14:
 2346              		.cfi_def_cfa_register 12
 2347 0594 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2348 0598 04B04CE2 		sub	fp, ip, #4
 2349              		.cfi_offset 14, -8
 2350              		.cfi_offset 13, -12
 2351              		.cfi_offset 11, -16
 2352              	.LCFI15:
 2353              		.cfi_def_cfa 11, 4
 2354 059c 10D04DE2 		sub	sp, sp, #16
 2355 05a0 0030A0E1 		mov	r3, r0
 2356 05a4 15304BE5 		strb	r3, [fp, #-21]
 173:../timer.c    **** 	int ret = 0;
 2357              		.loc 1 173 0
 2358 05a8 0030A0E3 		mov	r3, #0
 2359 05ac 10300BE5 		str	r3, [fp, #-16]
 174:../timer.c    **** 	int pos = t*4;
 2360              		.loc 1 174 0
 2361 05b0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2362 05b4 0331A0E1 		mov	r3, r3, asl #2
 2363 05b8 14300BE5 		str	r3, [fp, #-20]
 175:../timer.c    **** 	if (t > 0)
 2364              		.loc 1 175 0
 2365 05bc 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2366 05c0 000053E3 		cmp	r3, #0
 2367 05c4 0200000A 		beq	.L57
 176:../timer.c    **** 		pos += 4;
 2368              		.loc 1 176 0
 2369 05c8 14301BE5 		ldr	r3, [fp, #-20]
 2370 05cc 043083E2 		add	r3, r3, #4
 2371 05d0 14300BE5 		str	r3, [fp, #-20]
 2372              	.L57:
 177:../timer.c    **** 
 178:../timer.c    **** 	if ((t >= 0) && (t <= 5)
 2373              		.loc 1 178 0
 2374 05d4 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2375 05d8 050053E3 		cmp	r3, #5
 2376 05dc 0900008A 		bhi	.L58
 179:../timer.c    **** 			&& (rTCON & (0x1 << pos)))
 2377              		.loc 1 179 0
 2378 05e0 34309FE5 		ldr	r3, .L59
 2379 05e4 002093E5 		ldr	r2, [r3, #0]
 2380 05e8 0110A0E3 		mov	r1, #1
 2381 05ec 14301BE5 		ldr	r3, [fp, #-20]
 2382 05f0 1133A0E1 		mov	r3, r1, asl r3
 2383 05f4 033002E0 		and	r3, r2, r3
 2384 05f8 000053E3 		cmp	r3, #0
 2385 05fc 0100000A 		beq	.L58
 180:../timer.c    **** 		ret = 1;
 2386              		.loc 1 180 0
 2387 0600 0130A0E3 		mov	r3, #1
 2388 0604 10300BE5 		str	r3, [fp, #-16]
 2389              	.L58:
 181:../timer.c    **** 
 182:../timer.c    **** 	return ret;
 2390              		.loc 1 182 0
 2391 0608 10301BE5 		ldr	r3, [fp, #-16]
 183:../timer.c    **** }
 2392              		.loc 1 183 0
 2393 060c 0300A0E1 		mov	r0, r3
 2394 0610 0CD04BE2 		sub	sp, fp, #12
 2395 0614 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2396 0618 1EFF2FE1 		bx	lr
 2397              	.L60:
 2398              		.align	2
 2399              	.L59:
 2400 061c 0800D501 		.word	30736392
 2401              		.cfi_endproc
 2402              	.LFE7:
 2404              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer.c
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1698   .text:00000000 $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1701   .text:00000000 tmr_set_prescaler
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1772   .text:000000a8 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1776   .text:000000ac $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1779   .text:000000ac tmr_set_divider
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1885   .text:000001b4 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1889   .text:000001b8 $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1892   .text:000001b8 tmr_set_count
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1923   .text:000001f0 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:1931   .text:00000208 $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2006   .text:000002c0 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2020   .text:000002ec $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2023   .text:000002ec tmr_update
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2094   .text:00000394 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2098   .text:00000398 $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2101   .text:00000398 tmr_set_mode
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2193   .text:00000478 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2197   .text:0000047c $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2200   .text:0000047c tmr_start
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2261   .text:00000500 $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2265   .text:00000504 $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2268   .text:00000504 tmr_stop
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2330   .text:0000058c $d
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2334   .text:00000590 $a
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2337   .text:00000590 tmr_isrunning
C:\Users\ignac\AppData\Local\Temp\ccA48kFO.s:2400   .text:0000061c $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
